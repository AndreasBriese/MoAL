## Long term engineering learning path aka “MOAL” - Mother of All Learning

Mostly taken from: https://www.quora.com/What-is-the-best-way-to-self-teach-the-skills-and-knowledge-gained-in-a-typical-computer-science-degree/answer/Sam-Park-1?srid=dDmF&share=1

**THIS SHOULD ALL BE DONE IN PYTHON, EXCEPT FOR SPECIFIC LANGUAGE GOALS!
Also: things that are math oriented, should still be done IN an actual language -- utilize tools like numpy, scipy to do different types of math.**

## Strategy: "20 minutes a day"
Taken from: http://www.quora.com/What-small-lifestyle-changes-have-the-biggest-impact/answer/Evan-DeFilippis?srid=dDmF&share=1

# Specific tasks
_Note:_ *completed tasks will be ~~crossed out~~*

### Fundamentals

+ Try building a larger OOP-style project involving multiple classes.
+ Become familiar with some basic data structures/algorithms:
 + arrays
 + linked lists
 + Binary Search Trees
 + balanced Binary Search Trees 
  + (ex. Red-black trees
  + AVL trees)
 + heaps
 + sorting algorithms
   + insertion sort
    + merge sort
    + quick sort
+ discrete math: 
 + basic probability
 + basic number theory
 + set theory (notions of countably infinite vs. non-countably infinite)
 + automata theory/finite state machines

### Algorithms

+ Greedy algorithms
+ dynamic programming
+ divide and conquer
+ standard graph algorithms 
 + shortest path
 + max flow
 + MST
 + DFS/BFS

*Optional: Introduction to Algorithm Design by Jon Kleinberg and Eva Tardos, or Introduction to Algorithms CLRS (MIT).*

### Computer Organization

+ how a computer works
 + starting with transistors
 + logic gates
 + ALU
 + a basic CPU
 + caches
 + memory hierarchy
 + virtual memory
 + synchronization primitives
 + assembly languages
 + virtual memory
 + memory mapped I/O

### Operating Systems

+ concurrency
 + primitives
 + scheduling
 + single reader multiple writer
 + barrier
 + dining philosophers
+ memory management
+ networking
 + Ethernet
 + IP/TCP
 + UDP
 + SSH
+ file systems
+ security

### Advanced

+ More algorithms/data structures
 + spectral graph theory
 + linear programming/duality
+ advanced data structures (ex. persistent data structures)
 + approximation algorithms
+ Databases/Distributed Systems
+ Machine learning/Artificial Intelligence/Robotics
+ Theory of Computation
+ (various) automata
+ context-free languages
+ complexity classes (P, NP, #P, BPP, PSPACE)
+ PCPs,
+ circuit lower bounds
+ arithmetic complexity
+ quantum complexity
+ communication complexity
+ Unique Games Conjecture and its relation to optimality of approximation algorithms.
+ Programming Paradigms:
 + functional programming
 + Haskell
 + OCaml
 + Lisp
 + Clojure
+ logic programming
 + Prolog
+ theorem provers
+ verified computation
+ type systems
+ concurrency languages
 + GO
 + Rust
+ language based security
+ software defined networking.
+ Compilers:
 + building one
+ Computer Graphics
+ computational geometry
+ Scientific Computation
+ Cryptography and security
 + Diffie-Hellman
 + RSA
 + zero-knowledge proofs.
