MOAL
====

## Goals

MoAL - aka "Mother of All Learning" is a personal vision and project of mine, where the goal is to synthesize an extremely large set of computer science, software engineering, and computational science/math competencies into basic components, allowing one to learn a typically unfathomable breadth of topics in the field, doing so in a shorter amount of time. The trade off of **depth** is acceptable as it stresses basic competencies across all aspects, **which can later be translated into more detailed understanding**. However, it's important to note, many of these projects embody a reasonably deep level of understanding, and further enrich each competency by lateral connections of other, similar understandings that go beyond a typical, more familiar degree, comprised of a cross-section of coursework, that stresses only more common elements, while excluding others.

Each task is meant to be simple and atomic, so there is freedom to approach it however is most comfortable for a given learning style. Think of it like a jigsaw puzzle; while it's important to get the breadth and depth that makes a degree worthwhile, pieces are constantly being filled in, and this can be done line by line (linearly), or in a completely random fashion (or anything in-between).

This approach also embodies the Unix philosophy of "combining small, discrete tools to accomplish larger tasks."

__Enough talk! See [the tasks](TASKS.md) for more details__

## Motivations
The very first list was originally taken from: https://www.quora.com/What-is-the-best-way-to-self-teach-the-skills-and-knowledge-gained-in-a-typical-computer-science-degree/answer/Sam-Park-1?srid=dDmF&share=1, but it has been greatly expanded and re-organized. This will probably continue to change, which is why the atomic, containerization approach for each task is so important.

**To that end,** my goal is to do as much as can be done in python, except for specific language requirements. Things that are math, theory, or concept oriented should still be done in Python -- utilizing tools like numpy, scipy to do different types of computation.

Some examples are taken and/or recreated from other sites. In these cases, they are not copy-pasted verbatim; they are re-typed, character-by-character, modified, and heavily commented; the goal is not rote memorization. The goal is a genuine understanding and better intuition of how it works and how to do it. You may find it useful to recreate, modify, or start from scratch -- it is recommended to start from scratch when possible, but if you are honest with yourself, you will "know" when you comprehend it.

As mentioned before, in some cases, direct programming makes little sense since a given subject may be high level. However, to better understand and cement the idea, **it's important to try and recreate it in code**. For example, you can /learn/ about memory, but to **grok** it, you could write an actual module that acts as if it was memory - with the same kind of properties and functionality, albeit higher level.

## Accomplishing these tasks

### Strategy: "20 minutes a day"
This is not mandatory -- do whatever works best for you; but the "20 minute a day" approach is a good place to start ([you can read about it here](http://www.quora.com/What-small-lifestyle-changes-have-the-biggest-impact/answer/Evan-DeFilippis?srid=dDmF&share=1)). I find this approach helps get me motivated when the task seems daunting or I'm strapped for time -- 20 minutes is something anyone can commit to, and you'll be surprised how much can be accomplished when taken in aggregate -- it's all about building up change over the long term; don't obsess over the short term!

### Strategy part II: efficiency, and mastering the material
While this project is highly structured, it is still very organic. I have tuned and tweaked different strategies for learning as I've gone along.

One of these strategies is inspired by the ["Learning how to learn"](https://www.coursera.org/learn/learning-how-to-learn) course on Coursera. Having synthesized some of the tools there, I have created my own hybrid learning practice for each given task. The discrete nature of each task makes it very easy to find reference material and build out a study session that can be short and "mentally digestible".

Here it is:

1. Read up on a Wikipedia article giving an introduction to the concept (e.g. Binary Search Trees). Feel free to even browse Google images or the like for some conceptual examples to bring things together.
2. Watch a YouTube video explaining these concepts. Videos are fun and easy.
3. While doing 1 & 2 (or shortly after), create a mind map of all the concepts and phrases that came up, or in your mind. There is plenty of great mind map software, free and paid (I prefer [SimpleMind](http://www.simpleapps.eu/simplemind/), it's Android and Mac friendly, and works well, without the clutter).
4. Write the actual program for the actual task -- this is the most important, obviously.
5. Meditate on what you've learned!

My rationale for developing this approach comes from the notion that learning through multiple styles helps reinforce your overall understanding. Above, we have concrete verbal/spoken examples, conceptual examples, and practice, in not just one, but two forms (the actual programming and the mind-mapping).

With all of this you are creating an intuitive understanding while at the same time cementing it as detailed information. This makes retention much, much better.

### Embedding knowledge and infusing your understanding

One thing I have come to realize is that it is easy to simply "research and implement" the concept at hand, without fully appreciating what it means beyond the textbook definition. One of my goals here is to amass an extremely large cross-section of knowledge and also infuse that understanding into my own practice and disciplines. This approach allows novel thinking in one area, as one is more likely to take inspiration from a larger "pool" of tips and techniques that have been acquired.

So with that understanding, I would explicitly state here that when working on a project like this, it is important to allow the particular task at hand to envelop you, and infuse the idea into your knowledge. Each one will resonate with your own interests and understanding to a different degree, and that's fine; it's a matter of allowing yourself to grow by ingesting and transforming this knowledge, and not just memorizing a specific algorithm, data structure or concept.
